package imports

import (
	"os"
	"testing"
)

func TestParseIPTablesSave(t *testing.T) {
	input := `
# Generated by iptables-save
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
:DOCKER - [0:0]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A FORWARD -j DOCKER
-A FORWARD -o eth0 -j ACCEPT
-A FORWARD -i eth0 -j ACCEPT
COMMIT
# Completed
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
COMMIT
`
	tmpFile, err := os.CreateTemp("", "iptables-save-*")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpFile.Name())
	if _, err := tmpFile.Write([]byte(input)); err != nil {
		t.Fatal(err)
	}
	tmpFile.Close()

	rules, err := ParseIPTablesSave(tmpFile.Name())
	if err != nil {
		t.Fatalf("ParseIPTablesSave failed: %v", err)
	}

	// Filter table
	filter, ok := rules.Tables["filter"]
	if !ok {
		t.Fatal("Expected filter table")
	}

	inputChain, ok := filter.Chains["INPUT"]
	if !ok {
		t.Fatal("Expected INPUT chain")
	}

	foundSSH := false
	for _, r := range inputChain.Rules {
		if r.Protocol == "tcp" && r.DstPort == "22" && r.Target == "ACCEPT" {
			foundSSH = true
			break
		}
	}
	if !foundSSH {
		t.Error("SSH rule not found")
	}

	// NAT table
	nat, ok := rules.Tables["nat"]
	if !ok {
		t.Fatal("Expected nat table")
	}

	postrouting, ok := nat.Chains["POSTROUTING"]
	if !ok {
		t.Fatal("Expected POSTROUTING chain")
	}

	foundMasq := false
	for _, r := range postrouting.Rules {
		if r.Target == "MASQUERADE" && r.Source == "172.17.0.0/16" {
			foundMasq = true
			break
		}
	}
	if !foundMasq {
		t.Error("Masquerade rule not found")
	}
}

func TestParseIPTablesSave_Empty(t *testing.T) {
	// Empty file
	tmpFile, err := os.CreateTemp("", "iptables-empty-*")
	if err != nil {
		t.Fatal(err)
	}
	tmpFile.Close()
	defer os.Remove(tmpFile.Name())

	rules, err := ParseIPTablesSave(tmpFile.Name())
	if err == nil {
		// Empty file might be valid but produce no rules, or error if format check
		// Implementation dependent.
	} else if rules != nil && len(rules.Tables) != 0 {
		t.Error("Expected no tables")
	}
}

func TestIPTablesRuleToImported(t *testing.T) {
	// Test Case: Input Drop with Log
	input := `
*filter
:INPUT DROP [0:0]
-A INPUT -j LOG --log-prefix "Dropped: "
COMMIT
`
	tmpFile, err := os.CreateTemp("", "iptables-log-*")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpFile.Name())
	if _, err := tmpFile.Write([]byte(input)); err != nil {
		t.Fatal(err)
	}
	tmpFile.Close()

	result, _ := ParseIPTablesSave(tmpFile.Name())

	impResult := result.ToImportResult()

	foundLog := false
	for _, r := range impResult.FilterRules {
		if r.Log {
			foundLog = true
		}
	}
	if !foundLog {
		t.Error("Log rule not captured")
	}
}
